// index.js
import React, { useState, useEffect, useRef } from 'react';
import { File, Send, Loader2, CheckCircle2, AlertCircle, X, Bot, User, Trash2, Folder, ChevronRight, ChevronDown, RefreshCw, ExternalLink, FolderOpen, Cloud, CloudDownload, Clock, FileText, Image, FileCode, Archive, Activity, Zap, AlertTriangle, Wifi, WifiOff, Signal } from 'lucide-react';

// --- Enhanced Configuration ---
const API_CONFIG = {
    BASE_URL: "https://rag-gcs-718538538469.us-central1.run.app",
    TIMEOUTS: {
        HEALTH_CHECK: 15000,    // 15 seconds
        SYNC: 300000,           // 5 minutes (matches backend)
        QUERY: 40000,           // 40 seconds
        LIST_FILES: 20000,      // 20 seconds
        DEBUG: 10000            // 10 seconds
    },
    RETRY: {
        MAX_ATTEMPTS: 3,
        DELAY_MS: 2000,
        BACKOFF_MULTIPLIER: 2
    },
    POLLING: {
        SYNC_STATUS: 3000,      // 3 seconds
        DEBUG_INFO: 5000,       // 5 seconds
        CONNECTION: 30000       // 30 seconds
    }
};

// Frontend Version Info
const FRONTEND_VERSION = "v2.2.0-Enhanced-Reliability";
const FRONTEND_BUILD_DATE = "2025-07-31T00:00:00Z";

// Time formatting utilities
const formatTimestampWithTZ = (date = new Date()) => {
    try {
        return date.toLocaleString('en-US', {
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            timeZoneName: 'short'
        });
    } catch (error) {
        return new Date().toISOString();
    }
};

const getTimezone = () => {
    try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (error) {
        return 'UTC';
    }
};

// --- Enhanced API Client with Comprehensive Error Handling ---
class EnhancedAPIClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.requestCount = 0;
        this.errorCount = 0;
        this.successCount = 0;
        this.avgResponseTime = 0;
    }

    async makeRequest(endpoint, options = {}, timeout = 30000, retries = 3) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const requestId = ++this.requestCount;

        const requestOptions = {
            ...options,
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'X-Request-ID': requestId.toString(),
                ...options.headers
            }
        };

        for (let attempt = 1; attempt <= retries; attempt++) {
            const attemptStart = Date.now();
            
            try {
                console.log(`🔄 API Request #${requestId} (attempt ${attempt}/${retries}): ${endpoint}`);
                
                const response = await fetch(`${this.baseUrl}${endpoint}`, requestOptions);
                clearTimeout(timeoutId);

                const responseTime = Date.now() - attemptStart;
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMessage = errorData.detail || errorData.message || `HTTP ${response.status}`;
                    
                    if (response.status >= 500 && attempt < retries) {
                        console.log(`🔄 Server error ${response.status}, retrying...`);
                        await this.delay(this.getRetryDelay(attempt));
                        continue;
                    }
                    
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                
                // Update metrics
                this.successCount++;
                this.updateResponseTime(responseTime);
                
                console.log(`✅ API Success #${requestId} (attempt ${attempt}): ${endpoint} (${responseTime}ms)`);
                return data;

            } catch (error) {
                clearTimeout(timeoutId);

                if (error.name === 'AbortError') {
                    console.log(`⏰ API Timeout #${requestId} (attempt ${attempt}): ${endpoint}`);
                    if (attempt === retries) {
                        this.errorCount++;
                        throw new Error(`Request timed out after ${timeout/1000} seconds`);
                    }
                } else if (error.message.includes('message channel closed')) {
                    console.warn('Async response channel closed (likely extension interference):', error);
                    if (attempt === retries) {
                        this.errorCount++;
                        throw new Error('Network channel closed unexpectedly');
                    }
                } else {
                    console.log(`❌ API Error #${requestId} (attempt ${attempt}): ${endpoint} - ${error.message}`);
                    if (attempt === retries) {
                        this.errorCount++;
                        throw error;
                    }
                }

                // Wait before retry with exponential backoff
                if (attempt < retries) {
                    await this.delay(this.getRetryDelay(attempt));
                }
            }
        }
    }

    getRetryDelay(attempt) {
        return API_CONFIG.RETRY.DELAY_MS * Math.pow(API_CONFIG.RETRY.BACKOFF_MULTIPLIER, attempt - 1);
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    updateResponseTime(responseTime) {
        this.avgResponseTime = (this.avgResponseTime * (this.successCount - 1) + responseTime) / this.successCount;
    }

    getMetrics() {
        return {
            totalRequests: this.requestCount,
            successCount: this.successCount,
            errorCount: this.errorCount,
            successRate: this.requestCount > 0 ? (this.successCount / this.requestCount * 100).toFixed(1) : 0,
            avgResponseTime: Math.round(this.avgResponseTime)
        };
    }

    // API Methods
    async healthCheck() {
        return this.makeRequest('/health', {}, API_CONFIG.TIMEOUTS.HEALTH_CHECK, 2);
    }

    async syncDrive() {
        return this.makeRequest('/sync_drive', { method: 'POST' }, API_CONFIG.TIMEOUTS.SYNC, 2);  // Increased retries
    }

    async listFiles() {
        return this.makeRequest('/list_files', {}, API_CONFIG.TIMEOUTS.LIST_FILES, 3);  // Increased retries
    }

    async askQuestion(query, filters = []) {
        return this.makeRequest('/ask', {
            method: 'POST',
            body: JSON.stringify({ query, filters })
        }, API_CONFIG.TIMEOUTS.QUERY, 2);
    }

    async getSyncStatus() {
        return this.makeRequest('/sync_status', {}, API_CONFIG.TIMEOUTS.DEBUG, 1);
    }

    async getDebugInfo() {
        return this.makeRequest('/debug_live', {}, API_CONFIG.TIMEOUTS.DEBUG, 1);
    }

    async submitFeedback(feedbackData) {
        return this.makeRequest('/feedback', {
            method: 'POST',
            body: JSON.stringify(feedbackData)
        }, 10000, 1);
    }

    async emergencyReset() {
        return this.makeRequest('/emergency_reset', { method: 'POST' }, 15000, 1);
    }

    async testGoogleDriveAccess() {
        return this.makeRequest('/debug', {}, 10000, 1);
    }
}

// --- Helper Functions ---
const buildFileTreeFromPaths = (filePaths = []) => {
    console.log('Building file tree from paths:', filePaths);
    const tree = { name: 'root', children: {}, files: [], isFolder: true, path: '', fullPath: '' };
    
    if (!Array.isArray(filePaths)) {
        console.error('filePaths is not an array:', filePaths);
        return tree;
    }
    
    filePaths.forEach(filePath => {
        if (!filePath || typeof filePath !== 'string' || filePath.trim() === '') {
            console.warn('Invalid file path skipped:', filePath);
            return;
        }
        
        const parts = filePath.split('/').filter(part => part.trim() !== '');
        let currentNode = tree;
        let currentPath = '';
        
        parts.forEach((part, index) => {
            const isLastPart = index === parts.length - 1;
            const isFile = isLastPart && part.includes('.');
            
            currentPath = currentPath ? `${currentPath}/${part}` : part;
            
            if (isFile) {
                currentNode.files.push({
                    name: part,
                    path: currentPath,
                    fullPath: filePath,
                    isFile: true,
                    extension: part.split('.').pop()?.toLowerCase() || ''
                });
            } else {
                if (!currentNode.children[part]) {
                    currentNode.children[part] = {
                        name: part,
                        children: {},
                        files: [],
                        isFolder: true,
                        path: currentPath,
                        fullPath: currentPath
                    };
                }
                currentNode = currentNode.children[part];
            }
        });
    });
    
    console.log('Built file tree:', tree);
    return tree;
};

const getFileIcon = (extension) => {
    if (!extension) return <File className="h-4 w-4 text-slate-500" />;
    
    switch (extension) {
        case 'pdf':
            return <FileText className="h-4 w-4 text-red-500" />;
        case 'doc':
        case 'docx':
            return <FileText className="h-4 w-4 text-blue-500" />;
        case 'txt':
            return <FileText className="h-4 w-4 text-gray-500" />;
        case 'jpg':
        case 'jpeg':
        case 'png':
        case 'gif':
        case 'webp':
            return <Image className="h-4 w-4 text-green-500" />;
        case 'zip':
        case 'rar':
        case '7z':
            return <Archive className="h-4 w-4 text-purple-500" />;
        case 'js':
        case 'py':
        case 'html':
        case 'css':
        case 'json':
            return <FileCode className="h-4 w-4 text-orange-500" />;
        case 'xlsx':
        case 'xls':
        case 'csv':
            return <FileText className="h-4 w-4 text-green-600" />;
        default:
            return <File className="h-4 w-4 text-slate-500" />;
    }
};

const countFilesInNode = (node) => {
    if (!node || !node.files) return 0;
    let count = node.files.length;
    if (node.children) {
        Object.values(node.children).forEach(child => {
            count += countFilesInNode(child);
        });
    }
    return count;
};

const getAllFilePathsFromNode = (node) => {
    if (!node || !node.files) return [];
    let paths = node.files.map(file => file.fullPath || '').filter(Boolean);
    if (node.children) {
        Object.values(node.children).forEach(child => {
            paths = paths.concat(getAllFilePathsFromNode(child));
        });
    }
    return paths;
};

const renderTextWithLinks = (text) => {
    if (!text || typeof text !== 'string') return text;
    
    const urlRegex = /(https?:\/\/[^\s\)]+)/g;
    const parts = text.split(urlRegex);
    
    return parts.map((part, index) => {
        if (part.match(urlRegex)) {
            return (
                <a 
                    key={index}
                    href={part}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-600 hover:text-blue-800 underline font-medium"
                >
                    {part}
                </a>
            );
        }
        return part;
    });
};

// --- Enhanced Logo Component ---
const Logo = () => (
    <div className="w-8 h-8 flex items-center justify-center">
        <svg 
            width="32" 
            height="32" 
            viewBox="0 0 1024 1024" 
            xmlns="http://www.w3.org/2000/svg"
            className="w-8 h-8"
        >
            <defs>
                <radialGradient id="outerGrad" cx="30%" cy="30%">
                    <stop offset="0%" stopColor="#FDE047"/>
                    <stop offset="100%" stopColor="#F97316"/>
                </radialGradient>
                <radialGradient id="innerGrad" cx="30%" cy="30%">
                    <stop offset="0%" stopColor="#FEF3C7"/>
                    <stop offset="100%" stopColor="#FB923C"/>
                </radialGradient>
                <filter id="logoShadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="0" dy="2" stdDeviation="3" floodOpacity="0.25"/>
                </filter>
            </defs>
            <circle cx="512" cy="512" r="512" fill="url(#outerGrad)" filter="url(#logoShadow)"/>
            <circle cx="512" cy="512" r="384" fill="url(#innerGrad)"/>
            <circle cx="512" cy="512" r="192" fill="white"/>
        </svg>
    </div>
);

// --- Enhanced Connection Status Component ---
const ConnectionStatus = ({ apiClient, backendStatus, connectionQuality, onTest }) => {
    const [isTestingConnection, setIsTestingConnection] = useState(false);
    const [metrics, setMetrics] = useState(null);

    useEffect(() => {
        if (apiClient && typeof apiClient.getMetrics === 'function') {
            const updateMetrics = () => {
                try {
                    setMetrics(apiClient.getMetrics());
                } catch (error) {
                    console.warn('Error getting metrics:', error);
                }
            };
            updateMetrics();
            const interval = setInterval(updateMetrics, 5000);
            return () => clearInterval(interval);
        }
    }, [apiClient]);

    const getStatusColor = () => {
        switch (backendStatus) {
            case 'connected': 
                switch (connectionQuality) {
                    case 'excellent': return 'text-green-600';
                    case 'good': return 'text-green-500';
                    case 'fair': return 'text-yellow-600';
                    case 'poor': return 'text-orange-600';
                    default: return 'text-green-600';
                }
            case 'degraded': return 'text-orange-600';
            case 'disconnected': return 'text-red-600';
            case 'testing': return 'text-blue-600';
            default: return 'text-gray-600';
        }
    };
    
    const getStatusIcon = () => {
        switch (backendStatus) {
            case 'connected': return <Wifi className="w-3 h-3" />;
            case 'degraded': return <Signal className="w-3 h-3" />;
            case 'disconnected': return <WifiOff className="w-3 h-3" />;
            case 'testing': return <Loader2 className="w-3 h-3 animate-spin" />;
            default: return <AlertTriangle className="w-3 h-3" />;
        }
    };
    
    const getStatusText = () => {
        if (backendStatus === 'connected') {
            const qualityEmoji = {
                'excellent': '🟢',
                'good': '🟡',
                'fair': '🟠',
                'poor': '🔴'
            };
            return `${qualityEmoji[connectionQuality] || '🟢'} Connected`;
        } else if (backendStatus === 'degraded') {
            return '⚠️ Degraded';
        } else if (backendStatus === 'disconnected') {
            return '❌ Disconnected';
        } else if (backendStatus === 'testing') {
            return '🔄 Testing...';
        } else {
            return '❓ Unknown';
        }
    };

    const handleTest = async () => {
        setIsTestingConnection(true);
        try {
            if (onTest && typeof onTest === 'function') {
                await onTest();
            }
        } catch (error) {
            console.warn('Test connection error:', error);
        } finally {
            setIsTestingConnection(false);
        }
    };

    return (
        <div className="mt-2 space-y-2">
            <div className="flex items-center justify-center gap-2">
                <span className={`text-xs font-medium flex items-center gap-1 ${getStatusColor()}`}>
                    {getStatusIcon()}
                    {getStatusText()}
                </span>
                <button 
                    onClick={handleTest}
                    className="text-xs text-blue-600 hover:text-blue-800 underline disabled:opacity-50"
                    disabled={isTestingConnection || backendStatus === 'testing'}
                >
                    {isTestingConnection ? 'Testing...' : 'Test'}
                </button>
            </div>
            
            {/* Connection Metrics */}
            {metrics && (
                <div className="text-xs text-slate-500 space-y-1">
                    <div className="flex justify-between">
                        <span>Requests:</span>
                        <span>{metrics.totalRequests || 0}</span>
                    </div>
                    <div className="flex justify-between">
                        <span>Success Rate:</span>
                        <span className={(metrics.successRate || 0) >= 90 ? 'text-green-600' : (metrics.successRate || 0) >= 70 ? 'text-yellow-600' : 'text-red-600'}>
                            {metrics.successRate || 0}%
                        </span>
                    </div>
                    <div className="flex justify-between">
                        <span>Avg Response:</span>
                        <span className={(metrics.avgResponseTime || 0) < 2000 ? 'text-green-600' : (metrics.avgResponseTime || 0) < 5000 ? 'text-yellow-600' : 'text-red-600'}>
                            {metrics.avgResponseTime || 0}ms
                        </span>
                    </div>
                </div>
            )}
        </div>
    );
};

// --- Enhanced Progress Log Component ---
const ProgressLog = ({ progressLogs = [], isSyncing, onClear }) => {
    const logEndRef = useRef(null);

    useEffect(() => {
        if (logEndRef.current) {
            logEndRef.current.scrollIntoView({ behavior: 'smooth' });
        }
    }, [progressLogs]);

    const getLogColor = (level) => {
        switch (level) {
            case 'SUCCESS': return 'text-green-700 bg-green-50 border-green-200';
            case 'ERROR': return 'text-red-700 bg-red-50 border-red-200';
            case 'WARN': return 'text-orange-700 bg-orange-50 border-orange-200';
            case 'INFO': return 'text-blue-700 bg-blue-50 border-blue-200';
            case 'DEBUG': return 'text-purple-700 bg-purple-50 border-purple-200';
            default: return 'text-slate-700 bg-slate-50 border-slate-200';
        }
    };

    const getLogIcon = (level) => {
        switch (level) {
            case 'SUCCESS': return '✅';
            case 'ERROR': return '❌';
            case 'WARN': return '⚠️';
            case 'INFO': return 'ℹ️';
            case 'DEBUG': return '🔧';
            default: return '📝';
        }
    };

    return (
        <div className="bg-white border border-slate-200 rounded-lg overflow-hidden">
            <div className="bg-slate-900 px-3 py-2 border-b border-slate-200 flex items-center justify-between">
                <h3 className="text-sm font-semibold text-white flex items-center gap-2">
                    <Activity size={14} />
                    Progress Log
                    {isSyncing && (
                        <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
                    )}
                </h3>
                <div className="flex items-center gap-2">
                    <span className="text-xs text-slate-300">
                        {progressLogs.length} entries
                    </span>
                    {progressLogs.length > 0 && (
                        <button
                            onClick={onClear}
                            className="text-xs text-slate-300 hover:text-white px-2 py-1 rounded"
                        >
                            Clear
                        </button>
                    )}
                </div>
            </div>
            
            <div className="max-h-64 overflow-y-auto">
                {progressLogs.length === 0 ? (
                    <div className="p-4 text-center text-slate-500 text-sm">
                        No progress logs yet. Start a sync to see detailed progress.
                    </div>
                ) : (
                    <div className="p-2 space-y-1">
                        {progressLogs.map((log, index) => (
                            <div key={index} className={`text-xs p-2 rounded border ${getLogColor(log.level)}`}>
                                <div className="flex items-start gap-2">
                                    <span className="flex-shrink-0">{getLogIcon(log.level)}</span>
                                    <div className="flex-1 min-w-0">
                                        <div className="font-mono text-xs opacity-75 mb-1">
                                            {log.timestamp}
                                        </div>
                                        <div className="break-words">
                                            {log.message}
                                        </div>
                                        {log.details && (
                                            <div className="mt-1 text-xs opacity-75 font-mono">
                                                {log.details}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        ))}
                        <div ref={logEndRef} />
                    </div>
                )}
            </div>
        </div>
    );
};

// --- Enhanced Real-Time Debug Panel Component ---
class DebugErrorBoundary extends React.Component {
    state = { hasError: false };

    static getDerivedStateFromError(error) {
        return { hasError: true, error };
    }

    render() {
        if (this.state.hasError) {
            return <div className="p-4 bg-red-100 text-red-800 rounded">Debug panel error: {this.state.error.message}. Please refresh.</div>;
        }
        return this.props.children;
    }
}

const DebugPanel = ({ debugInfo, syncStatus, onEmergencyReset, isSyncing, backendVersion }) => {
    const [showDetails, setShowDetails] = useState(false);
    const [syncStartTime, setSyncStartTime] = useState(null);
    const [lastUpdate, setLastUpdate] = useState(null);

    // Track sync start time
    useEffect(() => {
        if (isSyncing && !syncStartTime) {
            setSyncStartTime(Date.now());
        } else if (!isSyncing && syncStartTime) {
            setSyncStartTime(null);
        }
    }, [isSyncing, syncStartTime]);

    // Track last update
    useEffect(() => {
        if (debugInfo) {
            setLastUpdate(Date.now());
        }
    }, [debugInfo]);

    const formatTime = (isoString) => {
        if (!isoString) return 'Never';
        return formatTimestampWithTZ(new Date(isoString));
    };

    const getOperationColor = (operation) => {
        if (!operation) return 'text-slate-600';
        if (operation.includes('error') || operation.includes('failed')) return 'text-red-600';
        if (operation.includes('timeout')) return 'text-orange-600';
        if (operation.includes('complete')) return 'text-green-600';
        if (operation.includes('sync') || operation.includes('processing')) return 'text-blue-600';
        return 'text-slate-600';
    };

    const getOperationIcon = (operation) => {
        if (!operation) return '📊';
        if (operation.includes('error') || operation.includes('failed')) return '❌';
        if (operation.includes('timeout')) return '⏰';
        if (operation.includes('complete')) return '✅';
        if (operation.includes('scanning')) return '🔍';
        if (operation.includes('processing')) return '⚙️';
        if (operation.includes('downloading')) return '⬇️';
        if (operation.includes('sync')) return '🔄';
        if (operation.includes('testing')) return '🧪';
        if (operation.includes('paginated')) return '📄';
        return '📊';
    };

    const getSyncDuration = () => {
        if (!syncStartTime) return 0;
        return Math.floor((Date.now() - syncStartTime) / 1000);
    };

    const formatDuration = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const getUpdateStatus = () => {
        if (!lastUpdate) return '❓ No data';
        const secondsAgo = Math.floor((Date.now() - lastUpdate) / 1000);
        if (secondsAgo < 3) return '🟢 Live';
        if (secondsAgo < 10) return '🟡 Recent';
        if (secondsAgo < 30) return '🟠 Stale';
        return '🔴 Old';
    };

    return (
        <div className="bg-white border border-slate-200 rounded-lg overflow-hidden">
            <div className="bg-slate-900 px-3 py-2 border-b border-slate-200 flex items-center justify-between">
                <h3 className="text-sm font-semibold text-white flex items-center gap-2">
                    <Activity size={14} />
                    System Monitor
                    {isSyncing && (
                        <div className="flex items-center gap-1">
                            <Loader2 size={12} className="animate-spin text-blue-400" />
                            <span className="text-xs text-blue-400">{formatDuration(getSyncDuration())}</span>
                        </div>
                    )}
                </h3>
                <div className="flex items-center gap-2">
                    <span className="text-xs text-slate-300">{getUpdateStatus()}</span>
                    <button
                        onClick={() => setShowDetails(!showDetails)}
                        className="text-xs text-slate-300 hover:text-white"
                    >
                        {showDetails ? 'Hide' : 'Show'} Details
                    </button>
                </div>
            </div>
            
            <div className="p-3 space-y-3 max-h-80 overflow-y-auto text-xs">
                {/* Version Information */}
                <div className="bg-indigo-50 border border-indigo-200 p-2 rounded">
                    <div className="font-semibold text-indigo-800 mb-1 flex items-center gap-1">
                        <Zap size={12} />
                        Version Info:
                    </div>
                    <div className="space-y-1 text-indigo-600">
                        <div className="flex justify-between">
                            <span>Frontend:</span>
                            <span className="font-mono">{FRONTEND_VERSION}</span>
                        </div>
                        <div className="flex justify-between">
                            <span>Backend:</span>
                            <span className="font-mono">{backendVersion || 'Loading...'}</span>
                        </div>
                        <div className="flex justify-between">
                            <span>Timezone:</span>
                            <span className="font-mono">{getTimezone()}</span>
                        </div>
                        <div className="text-xs text-indigo-500">
                            Current Time: {formatTimestampWithTZ()}
                        </div>
                    </div>
                </div>

                {/* Real-Time Sync Status */}
                {isSyncing && (
                    <div className="bg-blue-50 border border-blue-200 p-3 rounded-lg">
                        <div className="font-semibold text-blue-800 mb-2 flex items-center gap-2">
                            <Loader2 size={14} className="animate-spin" />
                            Live Sync Progress
                        </div>
                        <div className="space-y-2">
                            <div className="flex justify-between">
                                <span className="text-blue-700">Duration:</span>
                                <span className="font-mono text-blue-800">{formatDuration(getSyncDuration())}</span>
                            </div>
                            <div className="flex justify-between">
                                <span className="text-blue-700">Files Found:</span>
                                <span className="font-mono text-blue-800">{(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.files_found) || 0}</span>
                            </div>
                            <div className="flex justify-between">
                                <span className="text-blue-700">API Calls:</span>
                                <span className="font-mono text-blue-800">{(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.api_calls) || 0}</span>
                            </div>
                            {debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.performance && debugInfo.sync_progress.performance.files_per_second > 0 && (
                                <div className="flex justify-between">
                                    <span className="text-blue-700">Speed:</span>
                                    <span className="font-mono text-blue-800">
                                        {debugInfo.sync_progress.performance.files_per_second.toFixed(1)} files/sec
                                    </span>
                                </div>
                            )}
                            <div className="text-xs text-blue-600 mt-1">
                                Last Update: {lastUpdate ? formatTimestampWithTZ(new Date(lastUpdate)) : 'Never'}
                            </div>
                        </div>
                    </div>
                )}

                {/* Current Operation with Enhanced Details */}
                <div className="bg-slate-50 p-2 rounded">
                    <div className="font-semibold text-slate-700 mb-1">Current Operation:</div>
                    <div className={`font-mono flex items-center gap-2 ${getOperationColor(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.current_operation)}`}>
                        <span>{getOperationIcon(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.current_operation)}</span>
                        <span className="flex-1">{(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.current_operation) || 'idle'}</span>
                        {isSyncing && (
                            <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse" />
                        )}
                    </div>
                    {debugInfo && debugInfo.background_task && debugInfo.background_task.last_activity && (
                        <div className="text-xs text-slate-500 mt-1">
                            Last Activity: {formatTime(debugInfo.background_task.last_activity)}
                        </div>
                    )}
                </div>

                {/* Enhanced Key Metrics */}
                <div className="grid grid-cols-2 gap-2">
                    <div className="bg-green-50 p-2 rounded border border-green-200">
                        <div className="font-semibold text-green-700 flex items-center gap-1">
                            <FileText size={12} />
                            Files Found:
                        </div>
                        <div className="text-lg font-mono text-green-600 flex items-center gap-1">
                            {(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.files_found) || 0}
                            {isSyncing && debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.files_found > 0 && (
                                <span className="text-xs text-green-500">↗</span>
                            )}
                        </div>
                    </div>
                    <div className="bg-purple-50 p-2 rounded border border-purple-200">
                        <div className="font-semibold text-purple-700 flex items-center gap-1">
                            <Zap size={12} />
                            API Calls:
                        </div>
                        <div className="text-lg font-mono text-purple-600 flex items-center gap-1">
                            {(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.api_calls) || 0}
                            {isSyncing && debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.api_calls > 0 && (
                                <span className="text-xs text-purple-500">↗</span>
                            )}
                        </div>
                    </div>
                </div>

                {/* Current Folder Being Processed */}
                {debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.folder_stack && debugInfo.sync_progress.folder_stack.length > 0 && (
                    <div className="bg-yellow-50 border border-yellow-200 p-2 rounded">
                        <div className="font-semibold text-yellow-800 mb-1 flex items-center gap-1">
                            <Folder size={12} />
                            Processing:
                        </div>
                        <div className="font-mono text-yellow-700 text-xs truncate">
                            📁 {debugInfo.sync_progress.folder_stack[debugInfo.sync_progress.folder_stack.length - 1]?.path || 'root'}
                        </div>
                        {debugInfo.sync_progress.folder_stack.length > 1 && (
                            <div className="text-xs text-yellow-600 mt-1">
                                Depth: {debugInfo.sync_progress.folder_stack.length}
                            </div>
                        )}
                    </div>
                )}

                {/* Enhanced Performance Metrics */}
                {debugInfo && debugInfo.performance && (showDetails || isSyncing) && (
                    <div className="bg-blue-50 p-2 rounded border border-blue-200">
                        <div className="font-semibold text-blue-700 mb-1 flex items-center gap-1">
                            <Activity size={12} />
                            Performance:
                        </div>
                        <div className="space-y-1 text-blue-600">
                            {debugInfo.performance.files_per_second && (
                                <div className="flex justify-between">
                                    <span>Speed:</span>
                                    <span className="font-mono">{debugInfo.performance.files_per_second.toFixed(1)} files/sec</span>
                                </div>
                            )}
                            {debugInfo.performance.avg_processing_time && (
                                <div className="flex justify-between">
                                    <span>Avg Time:</span>
                                    <span className="font-mono">{debugInfo.performance.avg_processing_time.toFixed(1)}s</span>
                                </div>
                            )}
                            {debugInfo.performance.total_duration && (
                                <div className="flex justify-between">
                                    <span>Total:</span>
                                    <span className="font-mono">{Math.round(debugInfo.performance.total_duration)}s</span>
                                </div>
                            )}
                            {debugInfo.performance.files_processed && (
                                <div className="flex justify-between">
                                    <span>Processed:</span>
                                    <span className="font-mono">{debugInfo.performance.files_processed}</span>
                                </div>
                            )}
                        </div>
                    </div>
                )}

                {/* Thread and System Info */}
                {showDetails && (
                    <div className="bg-gray-50 p-2 rounded border border-gray-200">
                        <div className="font-semibold text-gray-700 mb-1">System Info:</div>
                        <div className="space-y-1 text-gray-600 text-xs">
                            {debugInfo && debugInfo.thread_id && (
                                <div>Thread ID: {debugInfo.thread_id}</div>
                            )}
                            {debugInfo && debugInfo.start_time && (
                                <div>Started: {formatTime(debugInfo.start_time)}</div>
                            )}
                            <div>Frontend Build: {new Date(FRONTEND_BUILD_DATE).toLocaleDateString()}</div>
                            <div>User Agent: {navigator.userAgent.split(' ').slice(-2).join(' ')}</div>
                        </div>
                    </div>
                )}

                {/* Folder Processing Stack */}
                {debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.folder_stack && debugInfo.sync_progress.folder_stack.length > 1 && showDetails && (
                    <div className="bg-indigo-50 p-2 rounded border border-indigo-200">
                        <div className="font-semibold text-indigo-700 mb-1 flex items-center gap-1">
                            <ChevronRight size={12} />
                            Processing Stack ({debugInfo.sync_progress.folder_stack.length}):
                        </div>
                        <div className="font-mono text-indigo-600 space-y-1 max-h-20 overflow-y-auto">
                            {debugInfo.sync_progress.folder_stack.slice(-4).map((folder, index) => (
                                <div key={index} className="truncate text-xs flex items-center gap-1">
                                    <span className="text-indigo-400">{'└'.repeat(index + 1)}</span>
                                    <span>📁 {folder.path || folder}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {/* Real-Time Errors */}
                {debugInfo && debugInfo.recent_errors && debugInfo.recent_errors.length > 0 && (
                    <div className="bg-red-50 p-2 rounded border border-red-200">
                        <div className="font-semibold text-red-700 mb-1 flex items-center gap-1">
                            <AlertCircle size={12} />
                            Recent Errors ({debugInfo.recent_errors.length}):
                        </div>
                        <div className="space-y-1 max-h-24 overflow-y-auto">
                            {debugInfo.recent_errors.slice(-3).map((error, index) => (
                                <div key={index} className="text-red-600 font-mono text-xs p-1 bg-red-100 rounded border">
                                    {error}
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {/* Emergency Reset */}
                <button
                    onClick={onEmergencyReset}
                    className="w-full flex items-center justify-center gap-2 bg-red-600 text-white font-semibold py-2 px-3 rounded hover:bg-red-700 transition-colors text-xs"
                    disabled={isSyncing}
                >
                    <Zap size={12} />
                    {isSyncing ? 'Sync In Progress...' : 'Emergency Reset'}
                </button>
            </div>
        </div>
    );
};

// --- Enhanced Google Drive Sync Panel ---
const GoogleDriveSyncPanel = ({ syncStatus, onSyncNow, googleDriveUrl, isSyncing, isMonitoring, debugInfo, addProgressLog, apiClient }) => {
    const [syncStartTime, setSyncStartTime] = useState(null);

    // Track sync start time
    useEffect(() => {
        if (isSyncing && !syncStartTime) {
            setSyncStartTime(Date.now());
        } else if (!isSyncing && syncStartTime) {
            setSyncStartTime(null);
        }
    }, [isSyncing, syncStartTime]);

    const formatTime = (isoString) => {
        if (!isoString) return 'Never';
        
        const date = new Date(isoString);
        const now = new Date();
        const diffMinutes = Math.floor((now - date) / 1000 / 60);
        
        if (diffMinutes < 1) return 'Just now';
        if (diffMinutes < 60) return `${diffMinutes}m ago`;
        if (diffMinutes < 1440) return `${Math.floor(diffMinutes/60)}h ago`;
        return date.toLocaleDateString();
    };

    const getSyncDuration = () => {
        if (!syncStartTime) return 0;
        return Math.floor((Date.now() - syncStartTime) / 1000);
    };

    const formatDuration = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const getSyncStatusColor = () => {
        if (isSyncing || (syncStatus && syncStatus.is_syncing)) return 'bg-blue-100 text-blue-800 border-blue-200';
        if (syncStatus && syncStatus.last_sync_results && syncStatus.last_sync_results.error) return 'bg-red-100 text-red-800 border-red-200';
        if (syncStatus && syncStatus.last_sync) return 'bg-green-100 text-green-800 border-green-200';
        return 'bg-gray-100 text-gray-800 border-gray-200';
    };

    const getSyncStatusText = () => {
        if (isSyncing || (syncStatus && syncStatus.is_syncing)) {
            const operation = debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.current_operation;
            if (operation && operation !== 'idle') {
                return `Syncing: ${operation}`;
            }
            return 'Syncing...';
        }
        if (syncStatus && syncStatus.last_sync_results && syncStatus.last_sync_results.error) return 'Sync failed';
        if (syncStatus && syncStatus.last_sync) return 'Synced';
        return 'Not synced';
    };

    const getSyncIcon = () => {
        if (isSyncing || (syncStatus && syncStatus.is_syncing)) return <Loader2 className="animate-spin" size={16} />;
        if (syncStatus && syncStatus.last_sync_results && syncStatus.last_sync_results.error) return <AlertCircle size={16} />;
        if (syncStatus && syncStatus.last_sync) return <CheckCircle2 size={16} />;
        return <Cloud size={16} />;
    };

    return (
        <div className="bg-white border border-slate-200 rounded-lg overflow-hidden">
            <div className="bg-slate-50 px-3 py-2 border-b border-slate-200">
                <h3 className="text-sm font-semibold text-slate-700 flex items-center gap-2">
                    <Cloud size={14} />
                    Google Drive Sync
                    {isMonitoring && (
                        <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" title="Monitoring active" />
                    )}
                </h3>
            </div>
            
            <div className="p-3 space-y-3">
                {/* Enhanced Sync Status */}
                <div className={`flex items-center gap-2 px-3 py-2 rounded border ${getSyncStatusColor()}`}>
                    {getSyncIcon()}
                    <div className="flex-1">
                        <div className="text-sm font-medium">{getSyncStatusText()}</div>
                        {isSyncing && syncStartTime && (
                            <div className="text-xs opacity-75 mt-0.5">
                                Duration: {formatDuration(getSyncDuration())}
                                {debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.files_found > 0 && (
                                    <span className="ml-2">• {debugInfo.sync_progress.files_found} files found</span>
                                )}
                                {debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.api_calls > 0 && (
                                    <span className="ml-2">• {debugInfo.sync_progress.api_calls} API calls</span>
                                )}
                            </div>
                        )}
                    </div>
                </div>

                {/* Real-time Sync Progress */}
                {isSyncing && (
                    <div className="bg-blue-50 border border-blue-200 p-2 rounded text-xs">
                        <div className="font-semibold text-blue-800 mb-1">Live Progress:</div>
                        <div className="space-y-1">
                            {debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.current_operation && debugInfo.sync_progress.current_operation !== 'idle' && (
                                <div className="text-blue-700 font-mono truncate">
                                    🔄 {debugInfo.sync_progress.current_operation}
                                </div>
                            )}
                            <div className="flex justify-between text-blue-600">
                                <span>Files: {(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.files_found) || 0}</span>
                                <span>API: {(debugInfo && debugInfo.sync_progress && debugInfo.sync_progress.api_calls) || 0}</span>
                                {debugInfo && debugInfo.performance && debugInfo.performance.files_per_second > 0 && (
                                    <span>{debugInfo.performance.files_per_second.toFixed(1)}/s</span>
                                )}
                            </div>
                        </div>
                    </div>
                )}

                {/* Google Drive Link and Test Button */}
                <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2 text-xs text-slate-600">
                        <Folder size={12} />
                        <span>Syncing from Google Drive</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <button
                            onClick={async () => {
                                try {
                                    addProgressLog('INFO', '🧪 Testing Google Drive access...', 'Checking backend Google Drive configuration');
                                    const debugData = await apiClient.testGoogleDriveAccess();
                                    
                                    addProgressLog('SUCCESS', 'Google Drive access test completed', JSON.stringify({
                                        drive_available: debugData.services && debugData.services.drive_service_available,
                                        drive_connection_test: debugData.services && debugData.services.drive_connection_test,
                                        gcp_project: debugData.services && debugData.services.gcp_project_id,
                                        folder_id: debugData.services && debugData.services.folder_id,
                                        processed_files: debugData.processed_files && debugData.processed_files.count
                                    }, null, 2));
                                } catch (error) {
                                    addProgressLog('ERROR', 'Google Drive access test failed', error.message);
                                }
                            }}
                            className="text-xs text-blue-600 hover:text-blue-800 px-2 py-1 rounded border border-blue-200 hover:bg-blue-50 transition-colors"
                            title="Test Google Drive access"
                        >
                            Test Access
                        </button>
                        {googleDriveUrl && (
                            <a 
                                href={googleDriveUrl} 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="text-blue-600 hover:text-blue-800 transition-colors"
                                title="Open Google Drive folder"
                            >
                                <ExternalLink size={14} />
                            </a>
                        )}
                    </div>
                </div>

                {/* Last Sync Info */}
                {syncStatus && syncStatus.last_sync && !isSyncing && (
                    <div className="text-xs text-slate-500 flex items-center gap-1">
                        <Clock size={12} />
                        Last sync: {formatTime(syncStatus.last_sync)}
                    </div>
                )}

                {/* Enhanced Sync Results */}
                {syncStatus && syncStatus.last_sync_results && !syncStatus.last_sync_results.error && !isSyncing && (
                    <div className="text-xs space-y-1 bg-slate-50 p-2 rounded">
                        <div className="font-semibold text-slate-700 mb-1">Last Sync Results:</div>
                        {syncStatus.last_sync_results.folders_scanned > 0 && (
                            <div className="text-blue-600">
                                📁 {syncStatus.last_sync_results.folders_scanned} folders scanned
                            </div>
                        )}
                        {syncStatus.last_sync_results.added && syncStatus.last_sync_results.added.length > 0 && (
                            <div className="text-green-600">
                                ➕ {syncStatus.last_sync_results.added.length} files added
                            </div>
                        )}
                        {syncStatus.last_sync_results.updated && syncStatus.last_sync_results.updated.length > 0 && (
                            <div className="text-blue-600">
                                🔄 {syncStatus.last_sync_results.updated.length} files updated
                            </div>
                        )}
                        {syncStatus.last_sync_results.skipped && syncStatus.last_sync_results.skipped.length > 0 && (
                            <div className="text-yellow-600">
                                ⏭️ {syncStatus.last_sync_results.skipped.length} files skipped
                            </div>
                        )}
                        {syncStatus.last_sync_results.errors && syncStatus.last_sync_results.errors.length > 0 && (
                            <div className="text-red-600">
                                ❌ {syncStatus.last_sync_results.errors.length} errors
                            </div>
                        )}
                    </div>
                )}

                {/* Error Display */}
                {syncStatus && syncStatus.last_sync_results && syncStatus.last_sync_results.error && !isSyncing && (
                    <div className="text-xs text-red-600 bg-red-50 p-2 rounded border border-red-200">
                        <div className="font-semibold mb-1">Error:</div>
                        <div className="break-words">{syncStatus.last_sync_results.error}</div>
                    </div>
                )}

                {/* Sync Button */}
                <button 
                    onClick={onSyncNow}
                    disabled={isSyncing || (syncStatus && syncStatus.is_syncing)}
                    className="w-full flex items-center justify-center gap-2 bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 disabled:bg-blue-400 disabled:cursor-not-allowed transition-colors"
                >
                    {(isSyncing || (syncStatus && syncStatus.is_syncing)) ? (
                        <>
                            <Loader2 className="animate-spin" size={16} />
                            Syncing... {syncStartTime && `(${formatDuration(getSyncDuration())})`}
                        </>
                    ) : (
                        <>
                            <RefreshCw size={16} />
                            Sync Now
                        </>
                    )}
                </button>

                {/* Next Auto Sync */}
                {syncStatus && syncStatus.next_auto_sync && !(isSyncing || (syncStatus && syncStatus.is_syncing)) && (
                    <div className="text-xs text-slate-500 text-center">
                        Next auto-sync: {formatTime(syncStatus.next_auto_sync)}
                    </div>
                )}
            </div>
        </div>
    );
};

// --- Enhanced File Tree Component ---
class ErrorBoundary extends React.Component {
    state = { hasError: false, error: null };

    static getDerivedStateFromError(error) {
        return { hasError: true, error };
    }

    render() {
        if (this.state.hasError) {
            return (
                <div className="p-4 bg-red-100 text-red-800 rounded">
                    Error rendering file tree: {this.state.error?.message}
                </div>
            );
        }
        return this.props.children;
    }
}

const FilePathTree = ({ filePaths = [], selectedDocs = [], onToggleDocSelection, onSelectAll }) => {
    const [expandedFolders, setExpandedFolders] = useState(new Set());
    
    const fileTree = buildFileTreeFromPaths(filePaths);
    const allFilePaths = filePaths.filter(path => path && path.includes('.'));
    const allSelected = allFilePaths.length > 0 && allFilePaths.every(path => selectedDocs.includes(path));

    useEffect(() => {
        if (Object.keys(fileTree.children).length > 0) {
            const rootFolders = Object.keys(fileTree.children);
            setExpandedFolders(new Set(rootFolders));
        }
    }, [filePaths]);

    const toggleFolder = (folderPath) => {
        setExpandedFolders(prev => {
            const newSet = new Set(prev);
            if (newSet.has(folderPath)) {
                newSet.delete(folderPath);
                const toRemove = Array.from(newSet).filter(p => p.startsWith(folderPath + '/'));
                toRemove.forEach(p => newSet.delete(p));
            } else {
                newSet.add(folderPath);
            }
            return newSet;
        });
    };

    const handleFolderToggle = (node) => {
        const folderFiles = getAllFilePathsFromNode(node);
        const allFolderFilesSelected = folderFiles.every(path => selectedDocs.includes(path));
        
        folderFiles.forEach(path => {
            if (allFolderFilesSelected && selectedDocs.includes(path)) {
                onToggleDocSelection(path);
            } else if (!allFolderFilesSelected && !selectedDocs.includes(path)) {
                onToggleDocSelection(path);
            }
        });
    };

    const renderNode = (node, level = 0) => {
        if (!node || typeof node !== 'object' || !('name' in node) || !('isFolder' in node)) {
            console.error('Invalid node in renderNode:', node);
            return null;
        }

        const isExpanded = expandedFolders.has(node.path);
        const hasChildren = Object.keys(node.children || {}).length > 0 || (node.files || []).length > 0;
        const fileCount = countFilesInNode(node);

        if (node.isFolder && node.name !== 'root') {
            const folderFiles = getAllFilePathsFromNode(node);
            const selectedCount = folderFiles.filter(path => selectedDocs.includes(path)).length;
            const allSelected = selectedCount === folderFiles.length && folderFiles.length > 0;
            const partiallySelected = selectedCount > 0 && selectedCount < folderFiles.length;

            return (
                <div key={node.path}>
                    <div
                        className="flex items-center gap-2 py-1.5 px-2 rounded group hover:bg-slate-50 transition-all duration-150"
                        style={{ paddingLeft: `${level * 16 + 4}px` }}
                    >
                        {hasChildren && (
                            <button
                                onClick={() => toggleFolder(node.path)}
                                className="p-0.5 hover:bg-slate-200 rounded transition-colors flex-shrink-0"
                            >
                                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                            </button>
                        )}
                        {!hasChildren && <div className="w-5" />}
                        
                        {folderFiles.length > 0 && (
                            <input
                                type="checkbox"
                                checked={allSelected}
                                ref={input => {
                                    if (input) input.indeterminate = partiallySelected;
                                }}
                                onChange={() => handleFolderToggle(node)}
                                className="form-checkbox h-3.5 w-3.5 text-blue-600 rounded border-slate-300 focus:ring-blue-500 flex-shrink-0"
                            />
                        )}
                        
                        <div 
                            className="flex items-center gap-2 flex-1 min-w-0 cursor-pointer"
                            onClick={() => hasChildren && toggleFolder(node.path)}
                        >
                            {isExpanded ? (
                                <FolderOpen className="h-4 w-4 text-blue-500 flex-shrink-0" />
                            ) : (
                                <Folder className="h-4 w-4 text-slate-500 flex-shrink-0" />
                            )}
                            
                            <span className="text-sm font-medium text-slate-900 truncate" title={node.name}>
                                {node.name}
                            </span>
                            
                            {fileCount > 0 && (
                                <span className="text-xs text-slate-500 flex-shrink-0">
                                    ({fileCount})
                                </span>
                            )}
                        </div>
                    </div>
                    
                    {isExpanded && hasChildren && (
                        <div>
                            {Object.values(node.children || {})
                                .sort((a, b) => a.name.localeCompare(b.name))
                                .map(child => {
                                    if (!child || typeof child !== 'object' || !('name' in child)) {
                                        console.error('Invalid child node:', child);
                                        return null;
                                    }
                                    return renderNode(child, level + 1);
                                })}
                            
                            {(node.files || [])
                                .sort((a, b) => a.name.localeCompare(b.name))
                                .map(file => {
                                    if (!file || typeof file !== 'object' || !('fullPath' in file)) {
                                        console.error('Invalid file entry:', file);
                                        return null;
                                    }
                                    return (
                                        <div
                                            key={file.fullPath}
                                            className={`flex items-center gap-2 py-1.5 px-2 rounded group cursor-pointer transition-all duration-150 ${
                                                selectedDocs.includes(file.fullPath) 
                                                    ? 'bg-blue-50 border border-blue-200' 
                                                    : 'hover:bg-slate-50'
                                            }`}
                                            style={{ paddingLeft: `${(level + 1) * 16 + 8}px` }}
                                            onClick={() => onToggleDocSelection(file.fullPath)}
                                        >
                                            <input
                                                type="checkbox"
                                                checked={selectedDocs.includes(file.fullPath)}
                                                onChange={() => onToggleDocSelection(file.fullPath)}
                                                className="form-checkbox h-3.5 w-3.5 text-blue-600 rounded border-slate-300 focus:ring-blue-500 flex-shrink-0"
                                                onClick={(e) => e.stopPropagation()}
                                            />
                                            {getFileIcon(file.extension)}
                                            <span className="text-sm text-slate-800 truncate flex-1" title={file.name}>
                                                {file.name}
                                            </span>
                                        </div>
                                    );
                                })}
                        </div>
                    )}
                </div>
            );
        }
        
        return null;
    };

    return (
        <ErrorBoundary>
            <div className="bg-white border border-slate-200 rounded-lg overflow-hidden">
                <div className="bg-slate-50 px-3 py-2.5 border-b border-slate-200 flex items-center justify-between">
                    <h3 className="text-sm font-semibold text-slate-700 flex items-center gap-2">
                        <Folder size={14} />
                        Knowledge Base
                        {allFilePaths.length > 0 && (
                            <span className="text-xs text-slate-500 font-normal">
                                ({allFilePaths.length} files)
                            </span>
                        )}
                    </h3>
                    {allFilePaths.length > 0 && (
                        <button 
                            onClick={onSelectAll} 
                            className="text-xs font-medium text-blue-600 hover:text-blue-800 px-2 py-1 rounded hover:bg-blue-50 transition-colors"
                        >
                            {allSelected ? 'Deselect All' : 'Select All'}
                        </button>
                    )}
                </div>
                
                <div className="p-2 max-h-96 overflow-y-auto">
                    {Object.keys(fileTree.children).length > 0 || fileTree.files.length > 0 ? (
                        <div className="space-y-0.5">
                            {Object.values(fileTree.children)
                                .sort((a, b) => a.name.localeCompare(b.name))
                                .map(child => renderNode(child, 0))}
                            
                            {fileTree.files
                                .sort((a, b) => a.name.localeCompare(b.name))
                                .map(file => (
                                    <div
                                        key={file.fullPath}
                                        className={`flex items-center gap-2 py-1.5 px-2 rounded group cursor-pointer transition-all duration-150 ${
                                            selectedDocs.includes(file.fullPath) 
                                                ? 'bg-blue-50 border border-blue-200' 
                                                : 'hover:bg-slate-50'
                                        }`}
                                        onClick={() => onToggleDocSelection(file.fullPath)}
                                    >
                                        <input
                                            type="checkbox"
                                            checked={selectedDocs.includes(file.fullPath)}
                                            onChange={() => onToggleDocSelection(file.fullPath)}
                                            className="form-checkbox h-3.5 w-3.5 text-blue-600 rounded border-slate-300 focus:ring-blue-500 flex-shrink-0"
                                            onClick={(e) => e.stopPropagation()}
                                        />
                                        {getFileIcon(file.extension)}
                                        <span className="text-sm text-slate-800 truncate flex-1" title={file.name}>
                                            {file.name}
                                        </span>
                                    </div>
                                ))}
                        </div>
                    ) : (
                        <div className="text-center text-sm text-slate-500 py-8">
                            <CloudDownload className="mx-auto h-12 w-12 text-slate-300 mb-3" />
                            <p>No documents synced yet</p>
                            <p className="text-xs mt-1">Add files to your Google Drive folder and sync</p>
                        </div>
                    )}
                </div>
            </div>
        </ErrorBoundary>
    );
};

// --- Enhanced Sidebar Component ---
const Sidebar = ({
    apiClient,
    availableDocs, 
    selectedDocs, 
    onToggleDocSelection, 
    onSelectAll,
    syncStatus,
    onSyncNow,
    googleDriveUrl,
    apiError,
    isSyncing,
    debugInfo,
    onEmergencyReset,
    backendStatus,
    connectionQuality,
    onTestConnection,
    isMonitoring,
    backendVersion,
    progressLogs,
    onClearProgressLogs,
    addProgressLog
}) => {
    return (
        <aside className="w-full lg:w-1/3 xl:w-1/4 bg-slate-50 border-r border-slate-200 p-4 flex flex-col space-y-4 overflow-hidden">
            <div className="text-center">
                <div className="flex items-center justify-center gap-3 mb-2">
                    <Logo />
                    <h1 className="text-2xl font-bold text-slate-800">Clair Enhanced</h1>
                </div>
                <p className="text-sm text-slate-600 mb-1 font-bold">随时守护您财富的智能专家</p>
                <p className="text-xs text-slate-500 font-medium">明智财富 - Production Edition</p>
                
                <ConnectionStatus 
                    apiClient={apiClient}
                    backendStatus={backendStatus}
                    connectionQuality={connectionQuality}
                    onTest={onTestConnection}
                />
            </div>
            
            {/* Debug Panel */}
            <div className="flex-shrink-0">
                <DebugErrorBoundary>
                    <DebugPanel
                        debugInfo={debugInfo}
                        syncStatus={syncStatus}
                        onEmergencyReset={onEmergencyReset}
                        isSyncing={isSyncing}
                        backendVersion={backendVersion}
                    />
                </DebugErrorBoundary>
            </div>

            {/* Progress Log */}
            <div className="flex-shrink-0">
                <ProgressLog
                    progressLogs={progressLogs}
                    isSyncing={isSyncing}
                    onClear={onClearProgressLogs}
                />
            </div>

            {/* Document Management */}
            <div className="flex-shrink-0">
                <h2 className="text-lg font-semibold text-slate-700 mb-3">Document Management</h2>
                
                <GoogleDriveSyncPanel
                    syncStatus={syncStatus}
                    onSyncNow={onSyncNow}
                    googleDriveUrl={googleDriveUrl}
                    isSyncing={isSyncing}
                    isMonitoring={isMonitoring}
                    debugInfo={debugInfo}
                    addProgressLog={addProgressLog}
                    apiClient={apiClient}
                />

                {apiError && (
                    <div className="mt-4 p-3 bg-red-100 border border-red-300 text-red-800 rounded-lg text-sm">
                        <div className="flex items-start gap-2">
                            <AlertCircle size={16} className="flex-shrink-0 mt-0.5" />
                            <div className="flex-1">
                                <p className="break-words">{apiError}</p>
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {/* Knowledge Base */}
            <div className="flex-1 flex flex-col min-h-0">
                <FilePathTree
                    filePaths={availableDocs}
                    selectedDocs={selectedDocs}
                    onToggleDocSelection={onToggleDocSelection}
                    onSelectAll={onSelectAll}
                />
            </div>
        </aside>
    );
};

// --- Enhanced Chat Area Component ---
const ChatArea = ({ messages, isSending, inputQuery, onInputChange, onSendMessage, chatEndRef, selectedDocsCount, onFeedback }) => (
    <main className="flex-1 flex flex-col bg-white">
        <div className="flex-1 p-6 overflow-y-auto">
            <div className="max-w-4xl mx-auto space-y-6">
                {messages.map((msg, index) => (
                    <div key={index} className={`flex items-start gap-4 ${msg.role === 'user' ? 'justify-end' : ''}`}>
                        {msg.role === 'ai' && (
                            <div className="flex-shrink-0 h-10 w-10 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full flex items-center justify-center shadow-md">
                                <Bot className="text-white" size={20} />
                            </div>
                        )}
                        <div className={`max-w-lg p-4 rounded-xl ${
                            msg.role === 'user' 
                                ? 'bg-blue-600 text-white' 
                                : msg.isError 
                                    ? 'bg-red-100 text-red-800 border border-red-200'
                                    : 'bg-slate-100 text-slate-800'
                        }`}>
                            <div className="whitespace-pre-wrap">
                                {renderTextWithLinks(msg.content)}
                            </div>
                            {msg.metadata && (
                                <div className="mt-2 pt-2 border-t border-slate-200 text-xs text-slate-500">
                                    <div className="flex items-center justify-between">
                                        <span>Documents: {msg.metadata.documentsUsed}</span>
                                        <span>{msg.metadata.model || 'gpt-4o'}</span>
                                    </div>
                                    {msg.metadata.status && msg.metadata.status !== 'success' && (
                                        <div className="mt-1">
                                            <span className={`px-2 py-1 rounded text-xs ${
                                                msg.metadata.status === 'timeout' ? 'bg-orange-100 text-orange-800' :
                                                msg.metadata.status === 'error' ? 'bg-red-100 text-red-800' :
                                                'bg-gray-100 text-gray-800'
                                            }`}>
                                                {msg.metadata.status}
                                            </span>
                                        </div>
                                    )}
                                </div>
                            )}
                            {msg.role === 'ai' && !msg.isError && !msg.feedbackGiven && (
                                <div className="mt-3 flex items-center gap-2">
                                    <span className="text-xs text-slate-500">Was this helpful?</span>
                                    <button 
                                        onClick={() => onFeedback(index, 'helpful')}
                                        className="text-xs px-2 py-1 bg-green-100 text-green-700 rounded hover:bg-green-200 transition-colors"
                                    >
                                        👍 Yes
                                    </button>
                                    <button 
                                        onClick={() => onFeedback(index, 'not_helpful')}
                                        className="text-xs px-2 py-1 bg-red-100 text-red-700 rounded hover:bg-red-200 transition-colors"
                                    >
                                        👎 No
                                    </button>
                                </div>
                            )}
                            {msg.feedbackGiven && (
                                <div className="mt-2 text-xs text-slate-500">
                                    Thank you for your feedback! ({msg.feedbackGiven})
                                </div>
                            )}
                        </div>
                        {msg.role === 'user' && (
                            <div className="flex-shrink-0 h-10 w-10 bg-slate-200 rounded-full flex items-center justify-center">
                                <User className="text-slate-600" />
                            </div>
                        )}
                    </div>
                ))}
                {isSending && (
                    <div className="flex items-start gap-4">
                        <div className="flex-shrink-0 h-10 w-10 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full flex items-center justify-center shadow-md">
                            <Bot className="text-white" size={20} />
                        </div>
                        <div className="max-w-lg p-4 rounded-xl bg-slate-100 text-slate-800">
                            <div className="flex items-center gap-2">
                                <Loader2 className="animate-spin" size={16} />
                                <span>Thinking with GPT-4o...</span>
                            </div>
                        </div>
                    </div>
                )}
                <div ref={chatEndRef} />
            </div>
        </div>
        <div className="bg-white border-t border-slate-200 p-4">
            <div className="max-w-4xl mx-auto">
                {selectedDocsCount > 0 && (
                    <div className="mb-2 text-xs text-slate-500">
                        Searching in {selectedDocsCount} selected document{selectedDocsCount !== 1 ? 's' : ''}
                    </div>
                )}
                <div className="relative">
                    <textarea 
                        value={inputQuery} 
                        onChange={onInputChange} 
                        onKeyDown={(e) => { 
                            if (e.key === 'Enter' && !e.shiftKey) { 
                                e.preventDefault(); 
                                onSendMessage(); 
                            } 
                        }} 
                        placeholder="Ask Clair about your financial and insurance documents... (Enhanced with GPT-4o)"
                        className="w-full min-h-[48px] max-h-32 p-3 pr-12 border border-slate-300 rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        rows={1}
                        disabled={isSending}
                    />
                    <button 
                        onClick={onSendMessage} 
                        disabled={isSending || !inputQuery.trim()} 
                        className="absolute right-3 top-1/2 -translate-y-1/2 bg-gradient-to-br from-yellow-400 to-orange-500 text-white p-2 rounded-full hover:from-yellow-500 hover:to-orange-600 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all shadow-md"
                    >
                        <Send size={16} />
                    </button>
                </div>
            </div>
        </div>
    </main>
);

// --- Main Enhanced Application Component ---
export default function EnhancedApp() {
    // Initialize API client
    const [apiClient] = useState(() => new EnhancedAPIClient(API_CONFIG.BASE_URL));
    
    // State management with safe defaults
    const [messages, setMessages] = useState([
        { 
            role: 'ai', 
            content: `Hello! I'm Clair Enhanced ${FRONTEND_VERSION}, your AI financial advisor powered by GPT-4o with comprehensive debugging and real-time monitoring. Current time: ${formatTimestampWithTZ()} (${getTimezone()}). I can help you understand your insurance policies, financial documents, and provide personalized financial guidance. Please sync your Google Drive folder to get started, then ask me any questions about your documents.` 
        }
    ]);
    const [inputQuery, setInputQuery] = useState('');
    const [isSending, setIsSending] = useState(false);
    const [availableDocs, setAvailableDocs] = useState([]);
    const [selectedDocs, setSelectedDocs] = useState([]);
    const [apiError, setApiError] = useState('');
    const [syncStatus, setSyncStatus] = useState(null);
    const [isSyncing, setIsSyncing] = useState(false);
    const [debugInfo, setDebugInfo] = useState(null);
    const [backendStatus, setBackendStatus] = useState('unknown');
    const [connectionQuality, setConnectionQuality] = useState('unknown');
    const [isMonitoring, setIsMonitoring] = useState(false);
    const [backendVersion, setBackendVersion] = useState(null);
    const [progressLogs, setProgressLogs] = useState([]);
    const [isInitialized, setIsInitialized] = useState(false);

    const chatEndRef = useRef(null);
    
    // Google Drive URL - update this with your actual folder
    const GOOGLE_DRIVE_URL = "https://drive.google.com/drive/folders/1pMiyyfk8hEoVVSsxMmRmobe6dmdm5sjI";

    // Add progress log entry
    const addProgressLog = (level, message, details = null) => {
        const logEntry = {
            timestamp: formatTimestampWithTZ(),
            level,
            message,
            details
        };
        
        setProgressLogs(prev => {
            const newLogs = [...prev, logEntry];
            // Keep only last 50 logs
            return newLogs.slice(-50);
        });
        
        console.log(`[${level}] ${formatTimestampWithTZ()}: ${message}${details ? ` - ${details}` : ''}`);
    };

    const clearProgressLogs = () => {
        setProgressLogs([]);
        addProgressLog('INFO', 'Progress logs cleared');
    };

    // Enhanced connection testing
    const testBackendConnection = async () => {
        try {
            setBackendStatus('testing');
            const startTime = Date.now();
            
            addProgressLog('INFO', 'Testing backend connection...');
            
            const healthData = await apiClient.healthCheck();
            const responseTime = Date.now() - startTime;
            
            // Extract backend version
            if (healthData && healthData.version) {
                setBackendVersion(healthData.version);
            }
            
            if (healthData && healthData.status === 'healthy') {
                setBackendStatus('connected');
                
                // Assess connection quality based on response time
                let quality = 'excellent';
                if (responseTime >= 1000) quality = 'good';
                if (responseTime >= 3000) quality = 'fair';
                if (responseTime >= 5000) quality = 'poor';
                setConnectionQuality(quality);
                
                addProgressLog('SUCCESS', `Backend connection successful (${responseTime}ms)`, `Quality: ${quality}, Version: ${healthData.version || 'unknown'}`);
                console.log(`✅ Backend connection successful (${responseTime}ms)`);
            } else {
                setBackendStatus('degraded');
                setConnectionQuality('poor');
                addProgressLog('WARN', 'Backend returned degraded status', JSON.stringify(healthData));
                console.log('⚠️ Backend returned degraded status');
            }
        } catch (error) {
            setBackendStatus('disconnected');
            setConnectionQuality('failed');
            addProgressLog('ERROR', 'Backend connection failed', error.message);
            console.log('❌ Backend connection failed:', error.message);
        }
    };

    // Enhanced sync handling with monitoring
    const handleSyncNow = async () => {
        try {
            setApiError('');
            setIsSyncing(true);
            
            clearProgressLogs(); // Clear old logs first
            addProgressLog('INFO', '🚀 Starting enhanced sync...', 'Preparing to sync Google Drive folder');
            console.log('🚀 Starting enhanced sync...');
            
            // Test connection first
            addProgressLog('DEBUG', 'Testing backend health before sync...');
            const healthData = await apiClient.healthCheck();
            if (!healthData || healthData.status !== 'healthy') {
                throw new Error(`Backend health check failed: ${healthData ? healthData.status : 'no response'}`);
            }
            
            addProgressLog('SUCCESS', 'Backend health check passed', `Status: ${healthData.status}`);
            
            // Test Google Drive access specifically
            addProgressLog('INFO', 'Testing Google Drive folder access...', `Folder ID: ${GOOGLE_DRIVE_URL.split('/').pop()}`);
            
            // Start sync
            addProgressLog('INFO', 'Initiating sync request...', 'Sending POST to /sync_drive');
            const syncStartTime = Date.now();
            
            const syncData = await apiClient.syncDrive();
            const syncRequestTime = Date.now() - syncStartTime;
            
            addProgressLog('SUCCESS', `Sync request completed in ${syncRequestTime}ms`, `Response: ${JSON.stringify(syncData)}`);
            console.log('📡 Enhanced sync response:', syncData);
            
            if (syncData && syncData.status === 'error') {
                throw new Error(syncData.message || 'Sync failed to start');
            }
            
            if (syncData && (syncData.status === 'started' || syncData.status === 'in_progress')) {
                addProgressLog('SUCCESS', 'Sync request accepted', `Status: ${syncData.status}`);
                
                // Monitor sync progress with enhanced logging
                monitorSyncProgressEnhanced();
            } else {
                addProgressLog('WARN', 'Unexpected sync response', `Status: ${syncData ? syncData.status : 'no response'}, Message: ${syncData ? syncData.message : 'none'}`);
                setIsSyncing(false);
            }
            
        } catch (error) {
            console.error('❌ Enhanced sync error:', error);
            setIsSyncing(false);
            
            let errorMessage = 'Sync failed';
            
            if (error.message.includes('timed out')) {
                errorMessage = 'Sync request timed out. The server may be processing large files. Monitoring will continue automatically.';
                addProgressLog('ERROR', 'Sync request timed out', 'Server may be processing large files or Google Drive access issues');
            } else if (error.message.includes('Failed to fetch')) {
                errorMessage = `Failed to connect to backend. Please check server status.`;
                addProgressLog('ERROR', 'Failed to connect to backend', 'Network connection issue or server down');
            } else if (error.message.includes('HTTP 503')) {
                errorMessage = 'Backend service temporarily unavailable. Please try again in a moment.';
                addProgressLog('ERROR', 'Backend service unavailable', 'HTTP 503 - Service temporarily unavailable');
            } else if (error.message.includes('HTTP 401')) {
                errorMessage = 'Google Drive access denied. Please check authentication.';
                addProgressLog('ERROR', 'Google Drive access denied', 'HTTP 401 - Authentication issue');
            } else if (error.message.includes('HTTP 403')) {
                errorMessage = 'Google Drive folder access forbidden. Please check permissions.';
                addProgressLog('ERROR', 'Google Drive folder access forbidden', 'HTTP 403 - Permission denied');
            } else {
                errorMessage = `Sync failed: ${error.message}`;
                addProgressLog('ERROR', 'Sync failed to start', error.message);
            }
            
            setApiError(errorMessage);
        }
    };

// Enhanced sync monitoring with stuck sync detection
const monitorSyncProgressEnhanced = () => {
    let attempts = 0;
    let stuckCount = 0;
    const maxAttempts = 120; // Monitor for up to 10 minutes
    const maxStuckCount = 10; // If no progress for 30 seconds, consider stuck
    let lastFilesFound = 0;
    let lastApiCalls = 0;
    let lastOperation = '';
    let syncStartTime = Date.now();
    let lastActivity = Date.now();
    let lastFile = null;
    
    addProgressLog('INFO', 'Starting enhanced sync monitoring...', 'Monitoring every 3 seconds with stuck detection');
    
    const checkSync = async () => {
        try {
            attempts++;
            const checkStartTime = Date.now();
            
            addProgressLog('DEBUG', `Monitor check #${attempts}`, `Checking sync status and debug info...`);
            
            const [status, debug] = await Promise.all([
                apiClient.getSyncStatus(),
                apiClient.getDebugInfo()
            ]);
            
            const checkDuration = Date.now() - checkStartTime;
            const totalSyncTime = Math.floor((Date.now() - syncStartTime) / 1000);
            
            addProgressLog('DEBUG', `Monitor check completed in ${checkDuration}ms`, `Total sync time: ${totalSyncTime}s`);
            
            // Check if sync has actually started
            if (status && !status.is_syncing && attempts <= 3) {
                addProgressLog('WARN', 'Sync not started yet', `Backend reports is_syncing: ${status.is_syncing}`);
                if (status.last_sync_results && status.last_sync_results.error) {
                    addProgressLog('ERROR', 'Sync failed to start', status.last_sync_results.error);
                    setIsSyncing(false);
                    setApiError(`Sync failed: ${status.last_sync_results.error}`);
                    return;
                }
            }
            
            // Log current backend state
            addProgressLog('DEBUG', 'Backend state', JSON.stringify({
                is_syncing: status ? status.is_syncing : false,
                operation: debug && debug.sync_progress ? debug.sync_progress.current_operation : null,
                files_found: debug && debug.sync_progress ? debug.sync_progress.files_found : 0,
                api_calls: debug && debug.sync_progress ? debug.sync_progress.api_calls : 0,
                thread_id: debug && debug.sync_progress ? debug.sync_progress.thread_id : null
            }));
            
            // Detect progress changes
            let progressMade = false;
            
            const currentFilesFound = debug && debug.sync_progress ? debug.sync_progress.files_found : 0;
            if (currentFilesFound !== lastFilesFound) {
                addProgressLog('INFO', `📄 Files found: ${lastFilesFound} → ${currentFilesFound}`, 'Google Drive file discovery progress');
                console.log(`📄 Files found: ${lastFilesFound} → ${currentFilesFound}`);
                lastFilesFound = currentFilesFound;
                progressMade = true;
            }
            
            const currentApiCalls = debug && debug.sync_progress ? debug.sync_progress.api_calls : 0;
            if (currentApiCalls !== lastApiCalls) {
                addProgressLog('INFO', `📡 API calls: ${lastApiCalls} → ${currentApiCalls}`, 'Google Drive API activity');
                console.log(`📡 API calls: ${lastApiCalls} → ${currentApiCalls}`);
                lastApiCalls = currentApiCalls;
                progressMade = true;
            }
            
            const currentOperation = debug && debug.sync_progress ? debug.sync_progress.current_operation : '';
            if (currentOperation && currentOperation !== lastOperation) {
                addProgressLog('INFO', `🔄 Operation: ${currentOperation}`, 'Current sync activity');
                console.log(`🔄 Operation: ${currentOperation}`);
                lastOperation = currentOperation;
                progressMade = true;
            }
            
            // Track folder being processed
            if (debug && debug.sync_progress && debug.sync_progress.folder_stack && debug.sync_progress.folder_stack.length > 0) {
                const currentFolder = debug.sync_progress.folder_stack[debug.sync_progress.folder_stack.length - 1];
                addProgressLog('INFO', `📁 Processing folder: ${currentFolder.path || 'root'}`, `Depth: ${debug.sync_progress.folder_stack.length}`);
            }
            
            // Performance metrics
            if (debug && debug.performance) {
                const metrics = debug.performance;
                if (metrics.files_per_second > 0) {
                    addProgressLog('INFO', `⚡ Processing speed: ${metrics.files_per_second.toFixed(1)} files/sec`, `Avg time: ${metrics.avg_processing_time ? metrics.avg_processing_time.toFixed(1) : 'unknown'}s`);
                }
            }
            
            const currentActivity = debug && debug.last_activity ? new Date(debug.last_activity).getTime() : Date.now();
            const activityElapsed = (Date.now() - currentActivity) / 1000;

            const currentFile = debug && debug.current_file;
            if (currentFile !== lastFile) {
                progressMade = true;
                lastFile = currentFile;
                addProgressLog('INFO', `Processing file: ${currentFile}`);
            }

            if (activityElapsed < 10) {  // Recent activity within 10s
                stuckCount = 0;
            } else if (!progressMade) {
                stuckCount++;
            }
            
            // Check if sync is stuck
            if (stuckCount >= maxStuckCount && status && status.is_syncing) {
                addProgressLog('ERROR', `Sync stuck for ${stuckCount * 3}s (last activity ${activityElapsed}s ago)`);
                if (debug && debug.recent_errors && debug.recent_errors.length > 0) {
                    debug.recent_errors.forEach(err => addProgressLog('CRITICAL', 'Recent error', JSON.stringify(err)));
                }
                setApiError(`Sync appears stuck. Timed out after ${activityElapsed.toFixed(1)} seconds of inactivity.`);
                setIsSyncing(false);
                return; // Stop monitoring
            }
            
            // Check if sync completed
            if (!status || !status.is_syncing) {
                setIsSyncing(false);
                addProgressLog('SUCCESS', '✅ Sync monitoring complete', `Total time: ${totalSyncTime}s`);
                console.log('✅ Sync monitoring complete');
                
                if (status && status.last_sync_results && status.last_sync_results.error) {
                    const errorMsg = `Sync completed with error: ${status.last_sync_results.error}`;
                    addProgressLog('ERROR', 'Sync completed with errors', status.last_sync_results.error);
                    setApiError(errorMsg);
                } else {
                    addProgressLog('SUCCESS', 'Sync completed successfully', JSON.stringify(status ? status.last_sync_results : {}));
                    console.log('✅ Sync completed successfully');
                    setApiError('');
                    // Refresh file list after successful sync
                    setTimeout(() => {
                        addProgressLog('INFO', 'Refreshing file list...', 'Getting updated document list');
                        fetchAvailableDocs();
                    }, 2000);
                }
                return;
            }
            
            // Continue monitoring
            if (attempts < maxAttempts) {
                setTimeout(checkSync, 3000); // Check every 3 seconds
            } else {
                setIsSyncing(false);
                addProgressLog('ERROR', 'Sync monitoring timed out', 'Reached maximum monitoring time (10 minutes)');
                setApiError('Sync monitoring timed out after 10 minutes. The sync may still be running.');
            }
            
        } catch (monitorError) {
            addProgressLog('ERROR', 'Sync monitoring error', monitorError.message);
            console.log('⚠️ Sync monitoring error:', monitorError.message);
            attempts++;
            if (attempts < maxAttempts) {
                setTimeout(checkSync, 5000);
            } else {
                setIsSyncing(false);
                addProgressLog('ERROR', 'Sync monitoring failed', 'Unable to monitor sync progress');
                setApiError('Sync monitoring failed. Check sync status manually.');
            }
        }
    };
    
    console.log('🔄 Starting enhanced sync monitoring...');
    setTimeout(checkSync, 3000); // Start monitoring after 3 seconds
};

    // Enhanced file fetching
    const fetchAvailableDocs = async () => {
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                setApiError('');
                addProgressLog('INFO', 'Fetching available documents...', 'Getting file list from backend');
                console.log('📁 Fetching available documents...');
                
                const data = await apiClient.listFiles();
                console.log('Raw file list response:', data);
                
                if (data && data.files && Array.isArray(data.files)) {
                    const fileList = data.files
                        .map(file => {
                            if (typeof file === 'string') {
                                return file;
                            } else if (file && typeof file === 'object' && file.path) {
                                console.warn('Unexpected file object in list:', file);
                                return file.path;
                            } else {
                                console.error('Invalid file entry:', file);
                                return null;
                            }
                        })
                        .filter(Boolean);
                    setAvailableDocs(fileList);
                    addProgressLog('SUCCESS', `Found ${fileList.length} documents`, 'Document list updated');
                } else {
                    setAvailableDocs([]);
                    addProgressLog('WARN', 'No documents found', 'Empty file list returned');
                }
                
                if (data && data.status === 'timeout') {
                    addProgressLog('WARN', 'File listing timed out', 'Some files may not be displayed');
                    setApiError('File listing timed out. Some files may not be displayed.');
                } else if (data && data.error) {
                    addProgressLog('ERROR', 'Could not fetch documents', data.error);
                    setApiError(`Could not fetch documents: ${data.error}`);
                }
                break;
            } catch (error) {
                addProgressLog('WARN', `File fetch attempt ${attempt} failed`, error.message);
                console.error('Error fetching docs:', error);
                
                if (attempt === 3) {
                    if (error.message.includes('timed out')) {
                        addProgressLog('WARN', 'File listing timed out', 'Network timeout occurred');
                        setApiError("File listing timed out. Please try the sync button to refresh.");
                    } else {
                        addProgressLog('ERROR', 'Failed to fetch documents', error.message);
                        setApiError(`Could not fetch documents: ${error.message}`);
                    }
                }
                await new Promise(r => setTimeout(r, 2000 * attempt));  // Backoff
            }
        }
    };

    // Enhanced status monitoring
    const fetchSyncStatus = async () => {
        try {
            const data = await apiClient.getSyncStatus();
            if (data) {
                setSyncStatus(data);
                if (data.debug_info && data.debug_info.recent_errors && data.debug_info.recent_errors.length > 0) {
                    data.debug_info.recent_errors.forEach(err => {
                        addProgressLog('ERROR', 'Backend error', err.error || JSON.stringify(err));
                    });
                }
                if (!data.is_syncing && isSyncing) {
                    setIsSyncing(false);
                }
            }
        } catch (error) {
            console.log('Sync status fetch failed:', error.message);
        }
    };

    const fetchDebugInfo = async () => {
        try {
            const data = await apiClient.getDebugInfo();
            if (data && data.debug_info) {
                console.log('Debug folder_stack:', data.debug_info?.folder_stack);
                setDebugInfo(data);
            }
        } catch (error) {
            console.log('Debug info fetch failed:', error.message);
        }
    };

    // Enhanced message sending
    const handleSendMessage = async () => {
        if (!inputQuery.trim() || isSending) return;
        
        const newQuery = inputQuery.trim();
        setMessages(prev => [...prev, { role: 'user', content: newQuery }]);
        setInputQuery('');
        setIsSending(true);
        
        addProgressLog('INFO', `Processing question: "${newQuery.substring(0, 50)}${newQuery.length > 50 ? '...' : ''}"`, `Using ${selectedDocs.length} selected documents`);
        
        try {
            const response = await apiClient.askQuestion(newQuery, selectedDocs);
            
            const aiResponse = (response && response.answer) || "Sorry, I couldn't generate a response.";
            
            addProgressLog('SUCCESS', 'Question processed successfully', `Model: ${response && response.model || 'gpt-4o'}, Status: ${response && response.status || 'success'}`);
            
            setMessages(prev => [...prev, { 
                role: 'ai', 
                content: aiResponse,
                metadata: {
                    timestamp: new Date().toISOString(),
                    documentsUsed: selectedDocs.length,
                    model: (response && response.model) || 'gpt-4o',
                    status: (response && response.status) || 'success',
                    contextUsed: (response && response.context_used) || false,
                    documentsSearched: (response && response.documents_searched) || 0
                }
            }]);
            
        } catch (error) {
            let errorMessage = "I'm having trouble connecting. Please try again.";
            
            if (error.message.includes('timed out')) {
                errorMessage = "The request timed out. Please try a simpler question or check your connection.";
                addProgressLog('WARN', 'Question processing timed out', error.message);
            } else if (error.message.includes('HTTP 503')) {
                errorMessage = "I'm experiencing technical difficulties. Please try again in a moment.";
                addProgressLog('ERROR', 'Service temporarily unavailable', 'HTTP 503 error');
            } else if (error.message.includes('HTTP 408')) {
                errorMessage = "Request timeout. Please try again with a shorter question.";
                addProgressLog('WARN', 'Request timeout', 'HTTP 408 error');
            } else if (error.message.includes('HTTP 500')) {
                errorMessage = "Server error. The development team has been notified. Please try again later.";
                addProgressLog('ERROR', 'Internal server error', 'HTTP 500 error');
            } else {
                addProgressLog('ERROR', 'Question processing failed', error.message);
            }
            
            setMessages(prev => [...prev, { 
                role: 'ai', 
                content: errorMessage,
                isError: true 
            }]);
            console.error('Enhanced message error:', error);
        } finally {
            setIsSending(false);
        }
    };

    // Enhanced feedback handling
    const handleFeedback = async (messageIndex, feedbackType) => {
        const message = messages[messageIndex];
        if (!message || message.role !== 'ai') return;

        const userMessage = messageIndex > 0 ? messages[messageIndex - 1] : null;
        if (!userMessage || userMessage.role !== 'user') return;

        try {
            await apiClient.submitFeedback({
                query: userMessage.content,
                response: message.content,
                feedback_type: feedbackType,
                documents_used: (message.metadata && message.metadata.documentsUsed) || 0,
                model: (message.metadata && message.metadata.model) || 'gpt-4o',
                context_used: (message.metadata && message.metadata.contextUsed) || false
            });

            addProgressLog('INFO', `Feedback submitted: ${feedbackType}`, 'User feedback recorded');

            setMessages(prev => prev.map((msg, idx) => 
                idx === messageIndex 
                    ? { ...msg, feedbackGiven: feedbackType }
                    : msg
            ));
        } catch (error) {
            addProgressLog('WARN', 'Failed to send feedback', error.message);
            console.error('Failed to send feedback:', error);
        }
    };

    // Enhanced emergency reset
    const handleEmergencyReset = async () => {
        try {
            addProgressLog('WARN', 'Emergency reset initiated', 'Clearing all data and resetting system');
            
            const result = await apiClient.emergencyReset();
            console.log('✅ Emergency reset successful:', result);
            
            // Reset local state
            setIsSyncing(false);
            setApiError('');
            setSyncStatus(null);
            setDebugInfo(null);
            setAvailableDocs([]);
            setSelectedDocs([]);
            
            addProgressLog('SUCCESS', 'Emergency reset completed', 'All systems reset successfully');
            
            // Refresh status
            setTimeout(() => {
                addProgressLog('INFO', 'Refreshing system status...', 'Getting updated system information');
                fetchSyncStatus();
                fetchDebugInfo();
                testBackendConnection();
            }, 1000);
            
        } catch (error) {
            addProgressLog('ERROR', 'Emergency reset failed', error.message);
            setApiError(`Emergency reset failed: ${error.message}`);
        }
    };

    const handleSelectAll = () => {
        const allFiles = availableDocs.filter(p => p && p.includes('.') && !p.endsWith('/'));
        const newSelection = selectedDocs.length === allFiles.length ? [] : allFiles;
        setSelectedDocs(newSelection);
        
        addProgressLog('INFO', newSelection.length === 0 ? 'Deselected all documents' : `Selected ${newSelection.length} documents`, 'Document selection updated');
    };

    // Safe initialization
    useEffect(() => {
        if (!isInitialized) {
            addProgressLog('INFO', `🚀 Initializing Enhanced RAG Clair System ${FRONTEND_VERSION}`, `Build date: ${FRONTEND_BUILD_DATE}`);
            console.log('🚀 Initializing Enhanced RAG Clair System...');
            
            // Initial setup with error handling
            const initialize = async () => {
                try {
                    await Promise.all([
                        fetchAvailableDocs().catch(e => console.log('Docs fetch failed:', e)),
                        fetchSyncStatus().catch(e => console.log('Sync status failed:', e)),
                        fetchDebugInfo().catch(e => console.log('Debug info failed:', e)),
                        testBackendConnection().catch(e => console.log('Connection test failed:', e))
                    ]);
                    
                    setIsMonitoring(true);
                    setIsInitialized(true);
                    addProgressLog('SUCCESS', 'System initialization complete', 'All monitoring services started');
                } catch (error) {
                    addProgressLog('ERROR', 'Initialization failed', error.message);
                    setIsInitialized(true); // Still set to true to prevent retry loops
                }
            };
            
            initialize();
        }
        
        return () => {
            setIsMonitoring(false);
        };
    }, [isInitialized]);

    // Safe polling intervals
    useEffect(() => {
        if (!isMonitoring || !isInitialized) return;

        const syncStatusInterval = setInterval(() => {
            fetchSyncStatus().catch(e => console.log('Sync status poll failed:', e));
        }, isSyncing ? 2000 : API_CONFIG.POLLING.SYNC_STATUS);
        
        const debugInfoInterval = setInterval(() => {
            fetchDebugInfo().catch(e => console.log('Debug info poll failed:', e));
        }, isSyncing ? 1500 : API_CONFIG.POLLING.DEBUG_INFO);
        
        const connectionInterval = setInterval(() => {
            testBackendConnection().catch(e => console.log('Connection test poll failed:', e));
        }, API_CONFIG.POLLING.CONNECTION);
        
        console.log(`📊 Polling intervals updated - Sync: ${isSyncing ? '2s' : '3s'}, Debug: ${isSyncing ? '1.5s' : '5s'}`);
        
        return () => {
            clearInterval(syncStatusInterval);
            clearInterval(debugInfoInterval);
            clearInterval(connectionInterval);
        };
    }, [isSyncing, isMonitoring, isInitialized]);

    // Auto-select all documents when first loaded
    useEffect(() => {
        if (availableDocs.length > 0 && selectedDocs.length === 0) {
            const allFiles = availableDocs.filter(p => p && p.includes('.') && !p.endsWith('/'));
            setSelectedDocs(allFiles);
            addProgressLog('INFO', `Auto-selected ${allFiles.length} documents`, 'All available documents selected for search');
        }
    }, [availableDocs, selectedDocs.length]);

    // Auto-scroll to bottom of chat
    useEffect(() => {
        if (chatEndRef.current) {
            chatEndRef.current.scrollIntoView({ behavior: 'smooth' });
        }
    }, [messages]);

    // Show loading state during initialization
    if (!isInitialized) {
        return (
            <div className="h-screen w-screen bg-slate-100 flex items-center justify-center">
                <div className="text-center">
                    <Loader2 className="w-8 h-8 animate-spin mx-auto mb-4 text-blue-600" />
                    <p className="text-slate-600">Initializing Enhanced RAG System...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="h-screen w-screen bg-slate-100 flex flex-col lg:flex-row font-sans">
            <Sidebar
                apiClient={apiClient}
                availableDocs={availableDocs} 
                selectedDocs={selectedDocs}
                onToggleDocSelection={(path) => setSelectedDocs(prev => prev.includes(path) ? prev.filter(p => p !== path) : [...prev, path])}
                onSelectAll={handleSelectAll}
                syncStatus={syncStatus}
                onSyncNow={handleSyncNow}
                googleDriveUrl={GOOGLE_DRIVE_URL}
                apiError={apiError}
                isSyncing={isSyncing}
                debugInfo={debugInfo}
                onEmergencyReset={handleEmergencyReset}
                backendStatus={backendStatus}
                connectionQuality={connectionQuality}
                onTestConnection={testBackendConnection}
                isMonitoring={isMonitoring}
                backendVersion={backendVersion}
                progressLogs={progressLogs}
                onClearProgressLogs={clearProgressLogs}
                addProgressLog={addProgressLog}
            />
            <ChatArea
                messages={messages} 
                isSending={isSending} 
                inputQuery={inputQuery}
                onInputChange={(e) => setInputQuery(e.target.value)}
                onSendMessage={handleSendMessage} 
                chatEndRef={chatEndRef}
                selectedDocsCount={selectedDocs.length}
                onFeedback={handleFeedback}
            />
        </div>
    );
};